/**\n * Comprehensive Integration Tests for Co-Scientist and Security Framework\n * \n * Tests the complete integration between research capabilities and security controls\n */\n\nimport { describe, test, expect, beforeEach, afterEach, beforeAll, afterAll } from '@jest/globals';\nimport { CoScientistSecurityIntegration } from '../../src/integrations/co-scientist-security-integration';\nimport { SecurityOptimizationManager } from '../../src/core/security-optimization-manager';\nimport { ModelOrchestrator } from '../../src/core/model-orchestrator';\nimport { PerformanceMonitor } from '../../src/core/performance-monitor';\nimport { AuthenticationManager } from '../../src/core/auth-manager';\nimport { ModelRouter } from '../../src/core/model-router';\nimport crypto from 'crypto';\n\ndescribe('Co-Scientist Security Integration', () => {\n  let integration: CoScientistSecurityIntegration;\n  let securityManager: SecurityOptimizationManager;\n  let mockOrchestrator: ModelOrchestrator;\n  let mockPerformance: PerformanceMonitor;\n  let mockAuth: AuthenticationManager;\n  let mockRouter: ModelRouter;\n\n  beforeAll(async () => {\n    // Initialize mock dependencies\n    mockOrchestrator = {} as ModelOrchestrator;\n    mockPerformance = {} as PerformanceMonitor;\n    mockAuth = {\n      getCurrentUserContext: jest.fn().mockResolvedValue({\n        id: 'test-user',\n        roles: ['researcher', 'admin'],\n        clearance: 'confidential'\n      }),\n      getCurrentUserId: jest.fn().mockResolvedValue('test-user'),\n      validateAccess: jest.fn().mockResolvedValue(true)\n    } as any;\n    mockRouter = {} as ModelRouter;\n    \n    // Initialize security manager\n    securityManager = new SecurityOptimizationManager(\n      mockOrchestrator,\n      mockPerformance,\n      mockAuth,\n      mockRouter\n    );\n    \n    // Initialize integration\n    integration = new CoScientistSecurityIntegration(securityManager);\n  });\n\n  afterAll(async () => {\n    // Cleanup\n  });\n\n  describe('Secure Research Session Management', () => {\n    test('should create secure research session with proper security controls', async () => {\n      const sessionParams = {\n        research_domain: 'artificial-intelligence',\n        data_classification: 'confidential' as const,\n        participants: [\n          {\n            type: 'human' as const,\n            identity: 'researcher@university.edu',\n            roles: ['lead_researcher'],\n            permissions: ['hypothesis_generation', 'data_analysis'],\n            security_clearance: 'confidential',\n            authentication_method: 'mfa'\n          },\n          {\n            type: 'agent' as const,\n            identity: 'research-coordinator',\n            roles: ['research_agent'],\n            permissions: ['academic_search', 'paper_generation'],\n            security_clearance: 'confidential',\n            authentication_method: 'api_key'\n          }\n        ],\n        compliance_requirements: ['GDPR', 'institutional_policy'],\n        research_objectives: [\n          'Investigate machine learning bias in healthcare applications',\n          'Develop mitigation strategies for algorithmic fairness'\n        ]\n      };\n\n      const session = await integration.createSecureResearchSession(sessionParams);\n\n      expect(session).toBeDefined();\n      expect(session.id).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/);\n      expect(session.security_context.data_classification).toBe('confidential');\n      expect(session.participants).toHaveLength(2);\n      expect(session.compliance_requirements).toContain('GDPR');\n      expect(session.status).toBe('active');\n      expect(session.threat_model_id).toBeDefined();\n      \n      // Verify security controls are applied\n      expect(session.security_context.clearance_level).toBe('confidential');\n      expect(session.security_context.audit_level).toBe('comprehensive');\n      \n      // Verify participants have session tokens\n      session.participants.forEach(participant => {\n        expect(participant.session_token).toBeDefined();\n        expect(participant.session_token.length).toBeGreaterThan(0);\n      });\n    });\n\n    test('should enforce data classification restrictions', async () => {\n      const restrictedSessionParams = {\n        research_domain: 'medical-research',\n        data_classification: 'restricted' as const,\n        participants: [\n          {\n            type: 'human' as const,\n            identity: 'researcher@hospital.org',\n            roles: ['medical_researcher'],\n            permissions: ['patient_data_access'],\n            security_clearance: 'restricted',\n            authentication_method: 'smart_card'\n          }\n        ],\n        compliance_requirements: ['HIPAA', 'GDPR'],\n        research_objectives: ['Clinical trial data analysis']\n      };\n\n      const session = await integration.createSecureResearchSession(restrictedSessionParams);\n\n      expect(session.security_context.data_classification).toBe('restricted');\n      expect(session.security_context.audit_level).toBe('forensic');\n      expect(session.compliance_requirements).toContain('HIPAA');\n    });\n\n    test('should reject session creation with insufficient permissions', async () => {\n      const invalidSessionParams = {\n        research_domain: 'classified-research',\n        data_classification: 'restricted' as const,\n        participants: [\n          {\n            type: 'human' as const,\n            identity: 'student@university.edu',\n            roles: ['student'],\n            permissions: ['read_only'],\n            security_clearance: 'public', // Insufficient clearance\n            authentication_method: 'password'\n          }\n        ],\n        compliance_requirements: [],\n        research_objectives: ['Access classified data']\n      };\n\n      await expect(\n        integration.createSecureResearchSession(invalidSessionParams)\n      ).rejects.toThrow(/insufficient.*clearance|permission.*denied/i);\n    });\n  });\n\n  describe('Secure Hypothesis Generation', () => {\n    let testSessionId: string;\n\n    beforeEach(async () => {\n      const session = await integration.createSecureResearchSession({\n        research_domain: 'machine-learning',\n        data_classification: 'internal',\n        participants: [{\n          type: 'human',\n          identity: 'test-researcher',\n          roles: ['researcher'],\n          permissions: ['hypothesis_generation'],\n          security_clearance: 'internal',\n          authentication_method: 'mfa'\n        }],\n        compliance_requirements: ['GDPR'],\n        research_objectives: ['Test hypothesis generation']\n      });\n      testSessionId = session.id;\n    });\n\n    test('should generate secure hypothesis with proper validation', async () => {\n      const hypothesisParams = {\n        domain: 'machine-learning',\n        background: 'Recent advances in transformer architectures',\n        observations: [\n          'Attention mechanisms improve model performance',\n          'Self-attention scales quadratically with sequence length'\n        ],\n        variables: {\n          independent: ['attention_heads', 'model_size'],\n          dependent: ['accuracy', 'inference_time'],\n          controlled: ['dataset', 'training_procedure']\n        },\n        methodology: 'experimental_design',\n        data_sources: ['public_datasets', 'synthetic_data']\n      };\n\n      const result = await integration.generateSecureHypothesis(\n        testSessionId,\n        hypothesisParams\n      );\n\n      expect(result.hypothesis).toBeDefined();\n      expect(result.hypothesis.id).toBeDefined();\n      expect(result.hypothesis.title).toContain('attention');\n      expect(result.security_context).toBeDefined();\n      expect(result.compliance_validation).toBeDefined();\n      expect(result.compliance_validation.status).toBe('compliant');\n      \n      // Verify hypothesis structure\n      expect(result.hypothesis.variables.independent).toEqual(hypothesisParams.variables.independent);\n      expect(result.hypothesis.variables.dependent).toEqual(hypothesisParams.variables.dependent);\n      expect(result.hypothesis.type).toMatch(/experimental|theoretical|computational|observational/);\n    });\n\n    test('should enforce data source restrictions', async () => {\n      const restrictedHypothesisParams = {\n        domain: 'medical-research',\n        background: 'Patient data analysis',\n        observations: ['Patient outcomes vary'],\n        variables: {\n          independent: ['treatment_type'],\n          dependent: ['recovery_time'],\n          controlled: ['age', 'gender']\n        },\n        data_sources: ['patient_records', 'medical_databases'] // Restricted sources\n      };\n\n      await expect(\n        integration.generateSecureHypothesis(testSessionId, restrictedHypothesisParams)\n      ).rejects.toThrow(/data.*source.*restricted|permission.*denied/i);\n    });\n\n    test('should apply appropriate security controls based on classification', async () => {\n      const confidentialSession = await integration.createSecureResearchSession({\n        research_domain: 'confidential-research',\n        data_classification: 'confidential',\n        participants: [{\n          type: 'human',\n          identity: 'senior-researcher',\n          roles: ['senior_researcher'],\n          permissions: ['hypothesis_generation', 'confidential_data_access'],\n          security_clearance: 'confidential',\n          authentication_method: 'smart_card'\n        }],\n        compliance_requirements: ['institutional_policy'],\n        research_objectives: ['Confidential research']\n      });\n\n      const hypothesisParams = {\n        domain: 'confidential-domain',\n        background: 'Confidential research background',\n        observations: ['Confidential observations'],\n        variables: {\n          independent: ['var1'],\n          dependent: ['var2'],\n          controlled: ['var3']\n        }\n      };\n\n      const result = await integration.generateSecureHypothesis(\n        confidentialSession.id,\n        hypothesisParams\n      );\n\n      expect(result.security_context.encryption_context).toBeDefined();\n      expect(result.security_context.classification).toBe('confidential');\n    });\n  });\n\n  describe('Secure Academic Database Integration', () => {\n    let testSessionId: string;\n\n    beforeEach(async () => {\n      const session = await integration.createSecureResearchSession({\n        research_domain: 'computer-science',\n        data_classification: 'internal',\n        participants: [{\n          type: 'human',\n          identity: 'test-researcher',\n          roles: ['researcher'],\n          permissions: ['academic_search'],\n          security_clearance: 'internal',\n          authentication_method: 'mfa'\n        }],\n        compliance_requirements: ['GDPR'],\n        research_objectives: ['Literature review']\n      });\n      testSessionId = session.id;\n    });\n\n    test('should perform secure academic search with proper filtering', async () => {\n      const searchQuery = {\n        keywords: ['machine learning', 'security'],\n        authors: ['Smith', 'Johnson'],\n        timeRange: {\n          start: new Date('2020-01-01'),\n          end: new Date('2023-12-31')\n        },\n        databases: ['arxiv', 'semantic_scholar'],\n        maxResults: 50\n      };\n\n      const result = await integration.performSecureAcademicSearch(\n        testSessionId,\n        searchQuery\n      );\n\n      expect(result.results).toBeDefined();\n      expect(Array.isArray(result.results)).toBe(true);\n      expect(result.security_metadata).toBeDefined();\n      expect(result.compliance_assessment).toBeDefined();\n      expect(result.compliance_assessment.status).toBe('compliant');\n      \n      // Verify security controls are applied\n      expect(result.security_metadata.data_classification).toBe('internal');\n      expect(result.security_metadata.audit_trail).toBe(true);\n    });\n\n    test('should apply data loss prevention controls', async () => {\n      const sensitiveSearchQuery = {\n        keywords: ['proprietary', 'confidential'],\n        databases: ['pubmed'],\n        maxResults: 10\n      };\n\n      const result = await integration.performSecureAcademicSearch(\n        testSessionId,\n        sensitiveSearchQuery\n      );\n\n      expect(result.security_metadata.access_restrictions).toBeDefined();\n      expect(result.results.every((r: any) => r.sanitized || r.redacted)).toBeTruthy();\n    });\n\n    test('should enforce export restrictions based on compliance', async () => {\n      const exportRestrictedQuery = {\n        keywords: ['export controlled technology'],\n        databases: ['all'],\n        maxResults: 100\n      };\n\n      await expect(\n        integration.performSecureAcademicSearch(testSessionId, exportRestrictedQuery)\n      ).rejects.toThrow(/export.*restricted|compliance.*violation/i);\n    });\n  });\n\n  describe('Secure Research Paper Generation', () => {\n    let testSessionId: string;\n    let hypothesisId: string;\n\n    beforeEach(async () => {\n      const session = await integration.createSecureResearchSession({\n        research_domain: 'artificial-intelligence',\n        data_classification: 'internal',\n        participants: [{\n          type: 'human',\n          identity: 'test-researcher',\n          roles: ['researcher'],\n          permissions: ['paper_generation', 'hypothesis_generation'],\n          security_clearance: 'internal',\n          authentication_method: 'mfa'\n        }],\n        compliance_requirements: ['GDPR'],\n        research_objectives: ['Research paper generation']\n      });\n      testSessionId = session.id;\n      \n      // Generate hypothesis first\n      const hypothesisResult = await integration.generateSecureHypothesis(\n        testSessionId,\n        {\n          domain: 'ai',\n          background: 'AI research',\n          observations: ['AI is advancing'],\n          variables: {\n            independent: ['model_size'],\n            dependent: ['performance'],\n            controlled: ['dataset']\n          }\n        }\n      );\n      hypothesisId = hypothesisResult.hypothesis.id;\n    });\n\n    test('should generate secure research paper with DRM protection', async () => {\n      const paperParams = {\n        hypothesisId,\n        sections: ['abstract', 'introduction', 'methodology', 'results', 'conclusion'],\n        citationStyle: 'APA',\n        targetJournal: 'Nature Machine Intelligence',\n        coAuthors: ['Dr. Smith', 'Dr. Johnson'],\n        publicationIntent: 'peer_review' as const\n      };\n\n      const result = await integration.generateSecureResearchPaper(\n        testSessionId,\n        paperParams\n      );\n\n      expect(result.paper).toBeDefined();\n      expect(result.document).toBeDefined();\n      expect(result.security_controls).toBeDefined();\n      expect(result.compliance_clearance).toBeDefined();\n      \n      // Verify DRM protection\n      expect(result.security_controls.drm_enabled).toBe(true);\n      expect(result.compliance_clearance.status).toBe('compliant');\n      \n      // Verify paper structure\n      expect(result.paper.title).toBeDefined();\n      expect(result.paper.authors).toContain('Dr. Smith');\n      expect(result.document.sections).toHaveProperty('abstract');\n      expect(result.document.sections).toHaveProperty('methodology');\n    });\n\n    test('should enforce publication restrictions for classified data', async () => {\n      const classifiedSession = await integration.createSecureResearchSession({\n        research_domain: 'classified-research',\n        data_classification: 'restricted',\n        participants: [{\n          type: 'human',\n          identity: 'cleared-researcher',\n          roles: ['senior_researcher'],\n          permissions: ['paper_generation', 'classified_access'],\n          security_clearance: 'restricted',\n          authentication_method: 'smart_card'\n        }],\n        compliance_requirements: ['classification_policy'],\n        research_objectives: ['Classified research']\n      });\n\n      const classifiedHypothesis = await integration.generateSecureHypothesis(\n        classifiedSession.id,\n        {\n          domain: 'classified',\n          background: 'Classified background',\n          observations: ['Classified observations'],\n          variables: {\n            independent: ['var1'],\n            dependent: ['var2'],\n            controlled: ['var3']\n          }\n        }\n      );\n\n      const publicationParams = {\n        hypothesisId: classifiedHypothesis.hypothesis.id,\n        publicationIntent: 'public' as const // Attempting public publication of classified data\n      };\n\n      await expect(\n        integration.generateSecureResearchPaper(classifiedSession.id, publicationParams)\n      ).rejects.toThrow(/publication.*restricted|clearance.*required/i);\n    });\n\n    test('should apply appropriate watermarking for internal papers', async () => {\n      const internalPaperParams = {\n        hypothesisId,\n        publicationIntent: 'internal' as const\n      };\n\n      const result = await integration.generateSecureResearchPaper(\n        testSessionId,\n        internalPaperParams\n      );\n\n      expect(result.security_controls.watermarking_applied).toBe(true);\n      expect(result.security_controls.copy_protection).toBe(true);\n    });\n  });\n\n  describe('Security and Compliance Monitoring', () => {\n    let testSessionId: string;\n\n    beforeEach(async () => {\n      const session = await integration.createSecureResearchSession({\n        research_domain: 'test-domain',\n        data_classification: 'internal',\n        participants: [{\n          type: 'human',\n          identity: 'test-user',\n          roles: ['researcher'],\n          permissions: ['all_research_operations'],\n          security_clearance: 'internal',\n          authentication_method: 'mfa'\n        }],\n        compliance_requirements: ['GDPR', 'institutional_policy'],\n        research_objectives: ['Test monitoring']\n      });\n      testSessionId = session.id;\n    });\n\n    test('should generate comprehensive security compliance report', async () => {\n      // Perform some research activities to generate audit data\n      await integration.generateSecureHypothesis(testSessionId, {\n        domain: 'test',\n        background: 'test',\n        observations: ['test'],\n        variables: { independent: ['a'], dependent: ['b'], controlled: ['c'] }\n      });\n\n      const report = await integration.generateSecurityComplianceReport(\n        testSessionId,\n        'comprehensive'\n      );\n\n      expect(report.report).toBeDefined();\n      expect(report.recommendations).toBeDefined();\n      expect(report.action_items).toBeDefined();\n      \n      // Verify report structure\n      expect(report.report.session_info).toBeDefined();\n      expect(report.report.security_metrics).toBeDefined();\n      expect(report.report.compliance_status).toBeDefined();\n      \n      // Verify metrics\n      expect(report.report.security_metrics.total_artifacts).toBeGreaterThan(0);\n      expect(report.report.security_metrics.security_events).toBeGreaterThan(0);\n    });\n\n    test('should detect and report security violations', async () => {\n      // Simulate a security violation by attempting unauthorized access\n      const unauthorizedQuery = {\n        keywords: ['classified', 'secret'],\n        databases: ['restricted_database']\n      };\n\n      try {\n        await integration.performSecureAcademicSearch(testSessionId, unauthorizedQuery);\n      } catch (error) {\n        // Expected to fail\n      }\n\n      const report = await integration.generateSecurityComplianceReport(\n        testSessionId,\n        'security_summary'\n      );\n\n      expect(report.report.security_metrics.access_violations).toBeGreaterThan(0);\n      expect(report.recommendations).toContain(\n        expect.stringMatching(/security.*violation|access.*control/i)\n      );\n    });\n\n    test('should track compliance with GDPR requirements', async () => {\n      const report = await integration.generateSecurityComplianceReport(\n        testSessionId,\n        'compliance_assessment'\n      );\n\n      expect(report.report.compliance_status).toHaveProperty('GDPR');\n      expect(report.report.compliance_status.GDPR.overall_status).toMatch(\n        /compliant|mostly_compliant|partially_compliant|non_compliant/\n      );\n    });\n\n    test('should provide actionable security recommendations', async () => {\n      const report = await integration.generateSecurityComplianceReport(\n        testSessionId,\n        'comprehensive'\n      );\n\n      expect(report.recommendations.length).toBeGreaterThan(0);\n      expect(report.action_items.length).toBeGreaterThan(0);\n      \n      // Verify recommendations are actionable\n      report.recommendations.forEach(recommendation => {\n        expect(recommendation).toMatch(/implement|configure|review|update|enhance/i);\n      });\n    });\n  });\n\n  describe('Session Lifecycle Management', () => {\n    test('should properly terminate research sessions', async () => {\n      const session = await integration.createSecureResearchSession({\n        research_domain: 'test',\n        data_classification: 'internal',\n        participants: [{\n          type: 'human',\n          identity: 'test-user',\n          roles: ['researcher'],\n          permissions: ['basic_research'],\n          security_clearance: 'internal',\n          authentication_method: 'password'\n        }],\n        compliance_requirements: [],\n        research_objectives: ['Test session termination']\n      });\n\n      await integration.terminateResearchSession(session.id, 'test_completed');\n\n      const activeSessions = integration.getActiveResearchSessions();\n      expect(activeSessions.find(s => s.id === session.id)).toBeUndefined();\n    });\n\n    test('should maintain audit trail throughout session lifecycle', async () => {\n      const session = await integration.createSecureResearchSession({\n        research_domain: 'audit-test',\n        data_classification: 'internal',\n        participants: [{\n          type: 'human',\n          identity: 'auditor',\n          roles: ['researcher'],\n          permissions: ['audit_trail_test'],\n          security_clearance: 'internal',\n          authentication_method: 'mfa'\n        }],\n        compliance_requirements: ['audit_policy'],\n        research_objectives: ['Test audit trail']\n      });\n\n      // Perform various activities\n      await integration.generateSecureHypothesis(session.id, {\n        domain: 'audit',\n        background: 'audit test',\n        observations: ['audit'],\n        variables: { independent: ['x'], dependent: ['y'], controlled: ['z'] }\n      });\n\n      await integration.terminateResearchSession(session.id, 'audit_test_completed');\n\n      const report = await integration.generateSecurityComplianceReport(\n        session.id,\n        'audit_trail'\n      );\n\n      expect(report.report.audit_trail).toBeDefined();\n      expect(report.report.audit_trail.events.length).toBeGreaterThan(0);\n      expect(report.report.audit_trail.events[0]).toHaveProperty('timestamp');\n      expect(report.report.audit_trail.events[0]).toHaveProperty('type');\n      expect(report.report.audit_trail.events[0]).toHaveProperty('outcome');\n    });\n  });\n\n  describe('Performance and Metrics', () => {\n    test('should track integration metrics accurately', async () => {\n      const initialMetrics = integration.getIntegrationMetrics();\n      \n      // Perform some operations\n      const session = await integration.createSecureResearchSession({\n        research_domain: 'metrics-test',\n        data_classification: 'internal',\n        participants: [{\n          type: 'human',\n          identity: 'metrics-tester',\n          roles: ['researcher'],\n          permissions: ['metrics_test'],\n          security_clearance: 'internal',\n          authentication_method: 'password'\n        }],\n        compliance_requirements: ['GDPR'],\n        research_objectives: ['Test metrics']\n      });\n\n      await integration.generateSecureHypothesis(session.id, {\n        domain: 'metrics',\n        background: 'metrics test',\n        observations: ['test'],\n        variables: { independent: ['a'], dependent: ['b'], controlled: ['c'] }\n      });\n\n      const finalMetrics = integration.getIntegrationMetrics();\n\n      expect(finalMetrics.secure_sessions_created).toBeGreaterThan(initialMetrics.secure_sessions_created);\n      expect(finalMetrics.research_artifacts_encrypted).toBeGreaterThan(initialMetrics.research_artifacts_encrypted);\n      expect(finalMetrics.compliance_checks_performed).toBeGreaterThan(initialMetrics.compliance_checks_performed);\n    });\n\n    test('should maintain acceptable performance under load', async () => {\n      const startTime = Date.now();\n      \n      // Create multiple concurrent sessions\n      const sessionPromises = Array.from({ length: 5 }, (_, i) => \n        integration.createSecureResearchSession({\n          research_domain: `load-test-${i}`,\n          data_classification: 'internal',\n          participants: [{\n            type: 'human',\n            identity: `load-tester-${i}`,\n            roles: ['researcher'],\n            permissions: ['load_test'],\n            security_clearance: 'internal',\n            authentication_method: 'password'\n          }],\n          compliance_requirements: [],\n          research_objectives: [`Load test ${i}`]\n        })\n      );\n\n      const sessions = await Promise.all(sessionPromises);\n      const endTime = Date.now();\n      const duration = endTime - startTime;\n\n      expect(sessions).toHaveLength(5);\n      expect(duration).toBeLessThan(10000); // Should complete within 10 seconds\n      \n      // Cleanup\n      await Promise.all(\n        sessions.map(session => \n          integration.terminateResearchSession(session.id, 'load_test_completed')\n        )\n      );\n    });\n  });\n});\n\n// Helper functions for testing\nfunction createMockModelOrchestrator(): Partial<ModelOrchestrator> {\n  return {\n    on: jest.fn(),\n    emit: jest.fn()\n  };\n}\n\nfunction createMockPerformanceMonitor(): Partial<PerformanceMonitor> {\n  return {\n    getMetrics: jest.fn().mockReturnValue({\n      requests: 100,\n      errors: 0,\n      latency: 150\n    })\n  };\n}\n\nfunction createMockModelRouter(): Partial<ModelRouter> {\n  return {\n    on: jest.fn(),\n    addRule: jest.fn()\n  };\n}"